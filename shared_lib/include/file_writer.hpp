#pragma once

// REF: this file is fully generated by claude.ai

#include <fstream>
#include <string>
#include <vector>
#include <memory>
#include <type_traits>
#include <filesystem>

enum class WriteMode
{
    Overwrite,  // Truncate and write from beginning
    Append,     // Append to end of file
    Binary      // Binary mode writing
};

class FileWriter
{
public:
    // Constructor with file path and mode
    explicit FileWriter(const std::filesystem::path& filePath, WriteMode mode = WriteMode::Overwrite)
        : m_filePath(filePath), m_mode(mode), m_isOpen(false)
    {
        Open();
    }

    // Destructor ensures file is closed
    ~FileWriter() { Close(); }

    // Delete copy constructor and assignment (RAII pattern)
    FileWriter(const FileWriter&) = delete;
    FileWriter& operator=(const FileWriter&) = delete;

    // Move constructor and assignment
    FileWriter(FileWriter&& other) noexcept
        : m_filePath(std::move(other.m_filePath)),
          m_mode(other.m_mode),
          m_stream(std::move(other.m_stream)),
          m_isOpen(other.m_isOpen)
    {
        other.m_isOpen = false;
    }

    FileWriter& operator=(FileWriter&& other) noexcept
    {
        if (this != &other)
        {
            Close();
            m_filePath = std::move(other.m_filePath);
            m_mode = other.m_mode;
            m_stream = std::move(other.m_stream);
            m_isOpen = other.m_isOpen;
            other.m_isOpen = false;
        }
        return *this;
    }

    // Check if file is successfully opened
    bool IsOpen() const { return m_isOpen && m_stream.is_open(); }

    // Write string content
    bool Write(const std::string& content)
    {
        if (!IsOpen()) return false;
        m_stream << content;
        return m_stream.good();
    }

    // Write string with newline
    bool WriteLine(const std::string& line)
    {
        if (!IsOpen()) return false;
        m_stream << line << '\n';
        return m_stream.good();
    }

    // Write binary data
    bool WriteBinary(const void* data, size_t size)
    {
        if (!IsOpen() || m_mode != WriteMode::Binary) return false;
        m_stream.write(static_cast<const char*>(data), size);
        return m_stream.good();
    }

    // Template function to write any type that supports operator<<
    template <typename T>
    bool Write(const T& data)
    {
        static_assert(std::is_arithmetic_v<T> || std::is_same_v<T, std::string>, "Type must support stream output");
        if (!IsOpen()) return false;
        m_stream << data;
        return m_stream.good();
    }

    // Write vector of data with separator
    template <typename T>
    bool WriteVector(const std::vector<T>& vec, const std::string& separator = " ")
    {
        if (!IsOpen()) return false;
        for (size_t i = 0; i < vec.size(); ++i)
        {
            m_stream << vec[i];
            if (i < vec.size() - 1)
            {
                m_stream << separator;
            }
        }
        return m_stream.good();
    }

    // Flush the stream
    bool Flush()
    {
        if (!IsOpen()) return false;
        m_stream.flush();
        return m_stream.good();
    }

    // Get current write position (for non-binary files)
    std::streampos GetPosition()
    {
        if (!IsOpen()) return -1;
        return m_stream.tellp();
    }

    // Seek to position (for non-binary files)
    bool SeekTo(std::streampos pos)
    {
        if (!IsOpen()) return false;
        m_stream.seekp(pos);
        return m_stream.good();
    }

    // Get file path
    const std::filesystem::path& GetFilePath() const { return m_filePath; }

    // Get file size
    size_t GetFileSize() const
    {
        if (!std::filesystem::exists(m_filePath)) return 0;
        return std::filesystem::file_size(m_filePath);
    }

    // Close file explicitly
    void Close()
    {
        if (m_stream.is_open())
        {
            m_stream.close();
        }
        m_isOpen = false;
    }

    // Reopen file (useful for changing modes)
    bool Reopen(WriteMode newMode = WriteMode::Overwrite)
    {
        Close();
        m_mode = newMode;
        return Open();
    }

    // Static utility functions
    static bool WriteToFile(const std::filesystem::path& filePath,
                            const std::string& content,
                            WriteMode mode = WriteMode::Overwrite)
    {
        FileWriter writer(filePath, mode);
        return writer.IsOpen() && writer.Write(content);
    }

    static bool AppendToFile(const std::filesystem::path& filePath, const std::string& content)
    {
        return WriteToFile(filePath, content, WriteMode::Append);
    }

private:
    bool Open()
    {
        try
        {
            // Create directories if they don't exist
            std::filesystem::create_directories(m_filePath.parent_path());

            std::ios_base::openmode openMode;
            switch (m_mode)
            {
                case WriteMode::Overwrite:
                    openMode = std::ios::out | std::ios::trunc;
                    break;
                case WriteMode::Append:
                    openMode = std::ios::out | std::ios::app;
                    break;
                case WriteMode::Binary:
                    openMode = std::ios::out | std::ios::binary | std::ios::trunc;
                    break;
            }

            m_stream.open(m_filePath, openMode);
            m_isOpen = m_stream.is_open();
            return m_isOpen;
        }
        catch (const std::exception&)
        {
            m_isOpen = false;
            return false;
        }
    }

    std::filesystem::path m_filePath;
    WriteMode m_mode;
    std::ofstream m_stream;
    bool m_isOpen;
};

// RAII helper for temporary file operations
class ScopedFileWriter
{
public:
    explicit ScopedFileWriter(const std::filesystem::path& filePath, WriteMode mode = WriteMode::Overwrite)
        : m_writer(std::make_unique<FileWriter>(filePath, mode))
    {
    }

    FileWriter* operator->() { return m_writer.get(); }
    FileWriter& operator*() { return *m_writer; }

    bool IsValid() const { return m_writer && m_writer->IsOpen(); }

private:
    std::unique_ptr<FileWriter> m_writer;
};

// Usage Examples:
/*

// Basic usage
Engine::FileWriter writer("output.txt");
if (writer.IsOpen()) {
    writer.WriteLine("Hello, World!");
    writer.Write("Line without newline");
    writer.Write(42);
    writer.Write(3.14f);
}

// Append mode
Engine::FileWriter appender("log.txt", Engine::WriteMode::Append);
appender.WriteLine("New log entry");

// Binary writing
Engine::FileWriter binaryWriter("data.bin", Engine::WriteMode::Binary);
int data[] = {1, 2, 3, 4, 5};
binaryWriter.WriteBinary(data, sizeof(data));

// Vector writing
std::vector<int> numbers = {1, 2, 3, 4, 5};
writer.WriteVector(numbers, ", ");

// Static utility
Engine::FileWriter::WriteToFile("quick.txt", "Quick write operation");

// RAII scoped writer
{
    Engine::ScopedFileWriter scoped("scoped.txt");
    if (scoped.IsValid()) {
        scoped->WriteLine("This will be cleaned up automatically");
    }
}

// Move semantics
Engine::FileWriter writer1("file1.txt");
Engine::FileWriter writer2 = std::move(writer1); // writer1 is now invalid

*/